#!/usr/bin/env python
import os
import github  # Install pygithub
import git     # Install gitpython
from argparse import ArgumentParser
import subprocess
import sys
import datetime
from configparser import ConfigParser
import logging
import pandas as pd


class ConfigError(Exception):
    pass


parser = ArgumentParser(
    description="""Helper script to mark GitHub Classroom assignments.""")
parser.add_argument("--config-file", type=str, action="store",
                    default="classroom-tool.cfg",
                    help="Location of classroom-tool config file.")
parser.add_argument("--log-level", type=str, action="store",
                    default="INFO",
                    help="Level of logging (defaults to INFO).")
parser.add_argument("--fetch", action="store_true",
                    help="Fetch all the student repositories.")
parser.add_argument("--create-branches", action="store_true",
                    help="Create student branches in the marking repository.")
parser.add_argument(
    "--impose-deadline", action="store_true",
    help="Create a branch pointing at the latest legal submission.")
parser.add_argument("--check-submissions", action="store_true",
                    help="Check datestamps on midterm submissions.")
parser.add_argument("--pull-requests", action="store_true",
                    help="Create marking pull requests.")

args = parser.parse_args()

log_level = getattr(logging, args.log_level.upper(), None)
if not isinstance(log_level, int):
    raise ValueError('Invalid log level: %s' % args.log_level)
logging.basicConfig(level=args.log_level, format='%(asctime)s %(message)s')

configparser = ConfigParser()
configparser.read(args.config_file)

if not configparser.sections():
    raise ConfigError(f"Missing or empty config file: {args.config_file}")


def config(section, key):
    try:
        sec = configparser[section]
    except KeyError:
        raise ConfigError(f"Config file is missing a {section} section.")

    try:
        return sec[key]
    except KeyError:
        raise ConfigError(f"Config file is missing a {section}->{key} entry.")

if "GITHUB_OAUTH" not in os.environ:
    ConfigError("The environment variable GITHUB_OAUTH"
                " must be set to a suitable GitHub personal access token.")
gh = github.Github(os.environ["GITHUB_OAUTH"])
orgname = config("github", "organization")
logging.info(f"Connecting to GitHub Organization {orgname}")
org = gh.get_organization(orgname)
repo = git.Repo(".")


def commit_time(commit):
    return commit.committed_datetime.astimezone().time().isoformat("seconds")


def get_remote(name, url):
    logging.info("Looking for remote %s" % name)
    try:
        remote = repo.remote(name)
        logging.info("Found")
    except ValueError:
        logging.info("Not found. Creating")
        remote = repo.create_remote(uname, url)
    return remote


class IdentityMap:
    def __getitem__(self, key):
        return key


def roster_map():
    """Return a map from GitHub to institution names.

    Return a dictionary mapping GitHub names back to institution names using the
    GitHub class roster specified in the students->roster configuration variable.
    """
    try:
        rosterfile = pd.read_csv(config("students", "roster"))
    except ConfigError:
        return IdentityMap()

    return {gh: i for gh, i in zip(rosterfile["github_username"],
                                   rosterfile["identifier"])
            if gh}


if args.fetch:
    count = 0

    reponame = config("github", "basename")
    name_offset = len(reponame) + 1

    for r in org.get_repos():
        if r.name.startswith(reponame):
            count += 1
            uname = "std_" + r.name[name_offset:]
            remote = get_remote(uname, r.ssh_url)
            logging.info("Fetching")
            remote.fetch()
    logging.info(f"{count} repos found.")


if args.create_branches:
    ident = roster_map()

    remote_prefix = "refs/remotes/std_"

    for ref in repo.refs:
        if ref.path.startswith(remote_prefix):
            gituser, branch = \
                ref.path[len(remote_prefix):].split("/")
            try:
                identifier = ident[gituser]
            except KeyError:
                logging.warning(f"No identifier found for {gituser} in roster.")
                continue
            if branch in ("master", "main", "feedback"):
                logging.info(f"Creating branch {identifier}-{branch}")
                repo.create_head(f"{identifier}-{branch}", ref.commit.hexsha)
            # Create the branch to mark.
            if branch in ("master", "main"):
                logging.info(f"Creating branch {identifier}-mark")
                repo.create_head(f"{identifier}-mark", ref.commit.hexsha)

    # if not config("github", "marking-repo"):
    #     raise ConfigError("Configuration parameter github->marking-repo absent.")
    # logging.info("Finding marking repository"
    #              f" {config('github', 'organization')}"
    #              f"/{config('github', 'marking-repo')}")
    # try:
    #     remote = repo.remote(config("github", "marking-repo"))
    # except ValueError:
    #     logging.info("Doesn't exist, creating.")
    #     try:
    #         marking_repo = org.get_repo(config("github", "marking-repo"))
    #     except github.GithubException:
    #         marking_repo = org.create_repo(config("github", "marking-repo"),
    #                                        private=True)
    #     remote = repo.create_remote(config("github", "marking-repo"),
    #                                 marking_repo.ssh_url)
    # remote.fetch()


    
#     marking_repos = {pull.title for pull in marking_repo.get_pulls()}

#     for r in org.get_repos():
#         if r.name.startswith("midterm-test-cards"):
#             uname = r.name[19:]
#             markname = uname.split("-")[0]
#             logging.info("Pushing main for remote %s" % uname)
#             remote.push("remotes/{0}/main:refs/heads/{0}-main".format(uname))
#             logging.info("Pushing feedback for remote %s" % uname)
#             remote.push("remotes/{0}/feedback:refs/heads/{0}-feedback".format(uname))
#             if uname not in marking_repos:
#                 logging.info("Creating pull request for %s" % uname)
#                 marking_repo.create_pull(title=uname,
#                                          body="Midterm marking.",
#                                          base=f"{uname}-feedback",
#                                          head=f"{uname}-main",
#                                          draft=False)

# cutoff = datetime.datetime(2021, 2, 26, 9, 42, tzinfo=datetime.timezone.utc)

# if args.impose_deadline:
#     # Note this is designed to be run from within the marking repo.
#     for r in repo.refs:
#         try:
#             branchname = r.path.split("/")[3]
#         except IndexError:
#             continue
#         if "-main" not in branchname:
#             continue
#         username = "-".join(branchname.split("-")[:-1])
#         c = r.commit
#         while c.committed_datetime > cutoff:
#             c = c.parents[0]
#         logging.info(f"{username}: last commit {commit_time(r.commit)}"
#               f" mark commit {commit_time(c)}")
#         try:
#             repo.create_head(username+"-mark", commit=c)
#         except OSError:
#             logging.info(f"Not moving {username}-mark.")
#         logging.info(f"Pushing {username}-mark")
#         repo.remote().push(username+"-mark")

# if args.check_midterm:
#     import pandas as pd

#     cloned = {}

#     for r in repo.refs:
#         if "-main" in r.path.split("/")[2]:
#             continue
#         if "-feedback" in r.path.split("/")[2]:
#             continue
#         if r.path.split("/")[2] == "midterm-marking":
#             continue
#         gituser = r.path.split("/")[2]
#         branch = r.path.split("/")[3]
#         try:
#             cloned[gituser, branch] = r
#         except KeyError:
#             cloned[gituser] = {}
#             cloned[gituser, branch] = r

#     for gituser, repos in cloned.items():
#         this = cloned[gituser]
#         this["attempted"] = \
#              this["main"].commit != this["feedback"].commit
#         this["late"] = this["main"].commit.committed_datetime > cutoff
#         this["submit_time"] = commit_time(this["main"].commit)

#     enrolled = pd.read_excel(os.environ["VIRTUAL_ENV"] + "/../midterm_admin/Students_taking_midterm.xlsx")
#     roster = pd.read_csv(os.environ["VIRTUAL_ENV"] + "/../midterm_admin/classroom_roster.csv")
#     imp_gh = dict(zip(map(str.lower, roster['identifier']), roster['github_username']))

#     out = {
#         "FirstName": [],
#         "LastName": [],
#         "Username": [],
#         "GitHub": [],
#         "Accessed": [],
#         "Attempted": [],
#         "Submit_time": [],
#         "Late": [],
#     }

#     for given, family, uname in zip(enrolled["FirstName"],
#                                     enrolled["LastName"],
#                                     map(str.lower, enrolled["Username"])):
#         out["FirstName"].append(given)
#         out["LastName"].append(family)
#         out["Username"].append(uname)
#         try:
#             this = cloned[imp_gh[uname]]
#         except KeyError:
#             out["GitHub"].append("")
#             out["Accessed"].append(False)
#             out["Attempted"].append(False)
#             out["Submit_time"].append("")
#             out["Late"].append(False)
#         else:
#             out["GitHub"].append(imp_gh[uname])
#             out["Accessed"].append(True)
#             out["Attempted"].append(this["attempted"])
#             out["Submit_time"].append(this["submit_time"])
#             out["Late"].append(this["late"])

#     df = pd.DataFrame(out).to_excel("MATH50009_midterm_attempts.xlsx")

# if args.pull_requests:
#     g = github.Github(os.environ["GITHUB_OAUTH"])
#     org = g.get_organization("Imperial-MATH50009")

#     remote = repo.remote()
#     marking_repo = org.get_repo("midterm-marking")
#     existing_pulls = {pull.head.ref for pull in marking_repo.get_pulls()}

#     for r in repo.refs:
#         if r.name.startswith("origin") and r.name.endswith("main"):
#             uname = r.name.split("/")[1, :-5]
#             if f"{uname}-mark" in existing_pulls:
#                 logging.info(f"skipping {uname}")
#                 continue
            
#             logging.info(uname)
#             marking_repo.create_pull(title=uname,
#                                          body="Midterm marking.",
#                                          base=f"{uname}-feedback",
#                                          head=f"{uname}-mark",
#                                          draft=False)

# if args.assign_markers:
#     g = github.Github(os.environ["GITHUB_OAUTH"])
#     org = g.get_organization("Imperial-MATH50009")

#     remote = repo.remote()
#     marking_repo = org.get_repo("midterm-marking")

